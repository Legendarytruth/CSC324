#lang racket #| CSC324 Fall 2019: Exercise 3 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc curry-2 fix-first curry-n)


;-------------------------------------------------------------------------------
; * Task 1: Building an environment *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout

  Calls the function `eval-calc` with an empty environment
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        Expanded Binary Arithmetic Expression Grammar in the handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html
    (look up `hash-ref`, `hash-set`, and `hash`)

  In Racket, the function `hash-set` takes a hash table, a new key-value pair,
  and returns a *new* hash table with all the elements in the old hash table,
  plus the new key-value pair.
|#
(define (symbol-finder fn)
  (cond
    [(equal? fn '+) +]
    [(equal? fn '-) -]
    [(equal? fn '*) *]
    [(equal? fn '/) /]
    [(equal? fn '=) =]
    [(equal? fn '>) >]
    [(equal? fn '<) <]
  
    ))

(define (eval-calc expr env)
  (cond
    [(null? expr) 0]
    [(number? expr) expr]
    [(symbol? expr) (hash-ref env expr)]
    [else (let([fn (first expr)] [rn (rest expr)])
            (cond
              [(equal? fn 'let*)
               (cond
                 [(and(equal? (length (first rn)) 1) (number? (cadr (first (first rn)))))
                  (eval-calc (second rn) (hash-set env (car (first (first rn))) (cadr (first (first rn)))))]
                 [(equal? (length (first rn)) 1) (eval-calc (second rn) (hash-set env (car (first (first rn))) (eval-calc (cadr (first (first rn))) env)))]
                 [(and(equal? (length (first rn)) 2) (number? (cadr (first (first rn)))) (number? (cadr (second (first rn)))))
                  (eval-calc (second rn) (hash-set* env (car (first (first rn))) (cadr (first (first rn))) (car (second (first rn))) (cadr (second (first rn)))))
                  ]
                 [(and(equal? (length (first rn)) 2) (number? (cadr (second (first rn)))))
                  (eval-calc (second rn) (hash-set* env (car (first (first rn))) (eval-calc (cadr (first (first rn))) env) (car (second (first rn))) (cadr (second (first rn)))))
                  ]
                 [(and(equal? (length (first rn)) 2) (number? (cadr (first (first rn)))))
                  (eval-calc (second rn) (hash-set* env (car (first (first rn))) (cadr (first (first rn))) (car (second (first rn))) (eval-calc (cadr (second (first rn))) env)))
                  ]
                 [(and(equal? (length (first rn)) 2))
                  (eval-calc (second rn) (hash-set* env (car (first (first rn))) (eval-calc (cadr (first (first rn))) env) (car (second (first rn))) (eval-calc (cadr (second (first rn))) env)))
                  ]
                 )]
              [(equal? fn 'if)
               (if((symbol-finder (first (first rn)))
                   (eval-calc (second (first rn)) env) (eval-calc (third (first rn)) env)) (eval-calc (second rn) env) (eval-calc (third rn) env))]
              [else
               (cond
                 [(and (number? (first rn))(number? (second rn))) ((symbol-finder fn) (first rn) (second rn))]
                 [(and (number? (first rn))(symbol? (second rn))) ((symbol-finder fn) (first rn) (eval-calc (second rn) env))]
                 [(and (symbol? (first rn))(number? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (second rn))]
                 [(and (symbol? (first rn))(symbol? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (eval-calc (second rn) env))]
                 [(and (symbol? (first rn))(list? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (eval-calc (second rn) env))]
                 [(and (list? (first rn))(symbol? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (eval-calc (second rn) env))]
                 [(and (number? (first rn))(list? (second rn))) ((symbol-finder fn) (first rn) (eval-calc (second rn) env))]
                 [(and (list? (first rn))(number? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (second rn))]
                 [(and (list? (first rn))(list? (second rn))) ((symbol-finder fn) (eval-calc (first rn) env) (eval-calc (second rn) env))]
                 )]))]))

(module+ test
  (require rackunit)
  (test-equal? "Environment lookup {a: 3}"
               (eval-calc '(+ a 1) (hash 'a 3))
               4)
  (test-equal? "Let* binding {a: 3}"
               (calculate '(let* ((a 3)) (+ a 1)))
               4)
  (test-equal? "Multiple binding {a: 3, b: 4}"
               (calculate '(let* ((a 3) (b 4)) (+ a b)))
               7)
  #;(test-equal? "Recursive bindings"
                 (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
                 8)
  (test-equal? "If statements with bindings"
               (calculate '(let* ((a 3) (b 3)) (if (= a b) 1 0)))
               1))


;-------------------------------------------------------------------------------
; * Task 2: Currying *
;-------------------------------------------------------------------------------
; Racket provides a built-in function "curry" that does the first task for you.
; You may NOT use this function in your code---submissions that do so will
; receive a grade of ZERO on the whole exercise!
(define (curry . rest) (error "curry: You may not use this function."))

#|
(curry-2 f)
  f: a *binary* function

  Returns a unary function g that takes an argument x, and returns a
  new unary function h that takes an argument y, such that
  (h y) is equivalent to (f x y).

  Here is a simple Python-style doctest for curry-2.
  We strongly recommend turning it into an executable test case,
  using the "module+ test" approach you've previously seen.

  > (define (add-2-mult x y) (* (+ 2 x) y))
  > (define func (curry-2 add-2-mult))
  > ((func 4) 5)
  30
|#
(define (curry-2 f)
  (lambda (x) (lambda (y) (f x y)))
  )

(module+ test
  (require rackunit)
  (test-equal? "curry-2/Addition"
               (let ([f (curry-2 (lambda (x y) (+ x y)))])
                 ((f 3) 5))  ; (f 3) is a function call!
               8))


#|
(define fix-first x f)
  x: a positive integer
  f: a function that takes at least 1 argument.

  Returns a new function g that takes one fewer argument than f,
  such that

  (g x2 x3 ... xn) == (f x x2 x3 ... xn)

  Hint: because the arity (number of arguments) of the returned function
  depends on the input f, you can't use something like (lambda (y z) ...)
  to define it. Instead, lookup *rest arguments* and *apply* to complete
  the function.

  Note: you don't need to do any "typechecking"---if the user passes the wrong
  number of arguments to the returned function, calling f should raise an error.
|#
(define (fix-first x f)
  (lambda y (apply f x y)))


(module+ test
  (test-equal? "fix-first/ternary"
               (let ([f2 (fix-first 3
                                    (lambda (x y z) (+ x (* y z))))])
                 (f2 5 8))
               ; We've deliberately left the body unexpanded to show what's going on.
               (+ 3 (* 5 8))))


#|
(curry-n n f)
  n: a positive integer
  f: a function that takes n arguments

  A generalization of curry-2, except now f takes n arguments;
  curry-n returns a function g that is the curried version of f.

  Notes and hints:
    1. It is possible to define curry-2 in terms of curry-n
       (but doing curry-2 yourself first is easier).
    2. Review the handout's examples of currying to determine the correct
       *recursive structure* for this function.
    3. If g = (curry-n n f), how is (g x) related to (fix-first x f)?
|#
(define (curry-n-helper n f accum)
  (cond
    [(equal? n 0) (apply f accum)]
    [else
     (lambda (acc) (curry-n-helper (- n 1) f (append accum (list acc))))
     ]))

(define (curry-n n f)
  (curry-n-helper n f (list))
  )

(module+ test
    ; NOTE: don't uncomment the test below until you've written
    ; your own test for a good *base case* for curry-n!
    ; (Until you're confident in your base case, you likely won't
    ; have much luck with a correct recursive case.)

    (test-equal? "curry-n/ternary"
                 (let ([f3 (curry-n 3
                                    (lambda (x y z) (+ x (* y z))))])
                   (((f3 3) 5) 8))
                 (+ 3 (* 5 8))))
