#lang racket
(define (test temp)
  (round(+(* temp 9/5) 32)))
(test 0)
(test 14)
(test -100)
(test 37)
(test 38)


(define (n-copies s n)
  (cond
    [(equal? n 0) ""]
    [(equal? n 1) s]
  [else (string-append s (n-copies s (- n 1)))]
))

(n-copies "Hello" 3)
(n-copies "Hello" 0)
(n-copies "a" 10)

(define (num-evens numbers)
  (cond
    [(null? numbers) 0]
    [else
     ; In this case the list is non-empty. Divide the list into its first
     ; element and the remaining numbers in the list, recurse on the remaining,
     ; and combine the results in some way to return the final result.
     (let ([first-number (first numbers)]
           [rest-number (num-evens (rest numbers))])  ; Pick a better variable name.
        (+  rest-number(if(equal? (modulo first-number 2) 0) 1 0)))]))


(define (num-many-evens lists-of-numbers)
  (cond
    [(null? lists-of-numbers) 0]
    [else 
    (let ([first-number (first lists-of-numbers)] [rest-number (rest lists-of-numbers)])
    (if (list? first-number) (+ (if (<= 3 (num-evens first-number)) 1 0))
        (num-many-evens (rest-number))))]))

;(num-many-evens (list (list 2 3 2 2)))
;(num-many-evens (list))

(define (num-many-evens2 lists-of-numbers)
  (cond
    [(null? lists-of-numbers) 0]
    [else (+ (num-many-evens2 (rest lists-of-numbers))
    (let ([first-number (first lists-of-numbers)])
    (if (list? first-number) (num-many-evens2 first-number)
        (if(equal? (modulo first-number 2) 0) 1 0))))]))

;(num-many-evens2 (list (list 2 3 4 2 2 2 (list 4 3 2))))

(define (genCounter2 lst)
  (if (empty? lst) 0
      (+ (genCounter2 (rest lst)) 
        (let ((first_number (first lst)))
           (if (list? first_number)
               (genCounter2 first_number) 
               (if(equal? (modulo first_number 2) 0) 1 0)))
        )))

;(genCounter2 (list (list 2 3 4 2 2 2)))

(define (genCounter lst target)
  (if (empty? lst)
      0
      (+ (genCounter (rest lst) target) 
         (let ((x (first lst)))
           (if (list? x)
               (genCounter x target) 
               (if (eqv? x target) 1 0))))))

;(genCounter '(3 (3 3 (3 3 3)) 3 (3 (3))) 3) 

;(num-many-evens null)
;(num-many-evens (list (list 2 4 5 7 8)))


(define (double-list numbers)
  (if (null? numbers)
      (list); What should this be?
      (cons (* 2 (first numbers)) (double-list (rest numbers)))) ; Hint: construct a list out of the first part of
                  ;       the answer, and use recursion for the rest
                  ;       of the answer.
  )
;(double-list null)
;(double-list (list 3 4 5))

#|
(calculate expr)
  expr: An expression generated by the Binary Arithmetic Expression Grammar
        described in the handout.

  Return the numerical value of the expression
|#

(define (my-map pred lst)
  (cond
    ((null? lst) '())
    ((not (pair? (car lst)))
     (cons (pred (car lst))
           (my-map pred (cdr lst))))
    (else
     (cons (my-map pred (car lst))
           (my-map pred (cdr lst))))))

(define (calculate expr)
  (cond
    [(null? expr) 0]
    [else (let ([first-number (first expr)] [rest-number (rest expr)])
    (if (and (pair? (first rest-number)) (symbol? first-number)) (calculate (first rest-number))
        ;(when (symbol? first-number)
         (cond [(equal? first-number '+) (+ (car rest-number)(cadr rest-number))]
          [(equal? first-number '-) (- (car rest-number)(cadr rest-number))]
          [(equal? first-number '/) (/ (car rest-number)(cadr rest-number))]
          [(equal? first-number '*) (* (car rest-number)(cadr rest-number))]);)
        ))]))

(calculate '(+ 2 3))
(calculate '(/ (+ 2 6) 2))

#;(module+ test
    (test-equal? "calculate: +"
                 (calculate '(+ 2 3)) ;'(+ 2 3) is the same as (list '+ 2 3)
                 5)
    (test-equal? "calculate: /"
                 (calculate '(/ (+ 2 6) 2))
                 4))

#|
(calculate-many exprs)
  exprs: A list of expressions, each generated from the
         Binary Arithmetic Expression Grammar described
         in the handout.

  Returns a list containing the values of each the expressions.
|#
(define (calculate-many exprs)
  (void))

#;(module+ test
    (test-equal? "calculate-many:"
                 (calculate-many '((+ 2 3) (/ (+ 2 6) 2))) ; '((+ 2 3) (/ 8 2)) is the same as
                 '(5 4)))                            ; (list (list '+ 2 3) (list '/ 8 2))