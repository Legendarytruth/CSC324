#lang racket #| CSC324 Fall 2019: Exercise 2 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/homework.html *
|#
;-------------------------------------------------------------------------------
; This expression exports functions so they can be imported into other files.
; Don't change it!
(provide calculate tail-calls)

;-------------------------------------------------------------------------------
; * Task 1: Calculator II *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: An expression generated by the Binary Arithmetic Expression Grammar
        in the Exercise 2 handout.

  Return the value of the expression
|#
(define (calculate expr)
  (void))

#;(module+ test
  (require rackunit)
  ; Please add additional test cases
  (test-equal? "Simple if statement"
               (calculate '(if (= 0 1) 4 5))
               5)
  (test-equal? "Nested if statement"
               (calculate '(+ 1 (if (= 0 1) 4 5)))
               6))

;-------------------------------------------------------------------------------
; * Task 2: Detecting tail calls *
;-------------------------------------------------------------------------------

#|
(tail-calls expr)
  expr: A racket datum with the structure defined on the exercise handout.

  Returns a *list of function call expressions* that are in tail call position
  with respect to the input expression.

  Feel free to change the define into define/match to use pattern-matching instead!
|#
(define (tail-calls expr)
  (void))


(module+ test
  (require rackunit)
  ; We've provided test cases for the first three syntactic forms described
  ; in the handout. Please add additional test cases, including ones for the
  ; other forms!
  (test-equal? "Atomic value" (tail-calls 3) empty)
  (test-equal? "Simple call" (tail-calls '(+ 1 2)) (list '(+ 1 2)))
  (test-equal? "Nested call"
               (tail-calls '(+ (* 3 4) 2))
               ; NOTE: the outermost expression is in tail-call position,
               ; and it should just be output directly. Don't try to evaluate
               ; the inner '(* 3 4) -- this is harder to do!
               (list '(+ (* 3 4) 2)))
  (test-equal? "Simple if" (tail-calls '(if (> x 0) (- x 2) (+ x 3)))
               (list '(- x 2)
                     '(+ x 3))))
